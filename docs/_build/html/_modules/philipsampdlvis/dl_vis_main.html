
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>philipsampdlvis.dl_vis_main &#8212; Philipsampdlvis 0.0.post0.dev1+ng24b0d90.dirty documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0.post0.dev1+ng24b0d90.dirty',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for philipsampdlvis.dl_vis_main</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">keras</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">keras</span> <span class="k">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">import</span> <span class="nn">dl_vis_utils</span> <span class="k">as</span> <span class="nn">utils</span>

<div class="viewcode-block" id="AMPDLVisualization"><a class="viewcode-back" href="../../api/philipsampdlvis.html#philipsampdlvis.dl_vis_main.AMPDLVisualization">[docs]</a><span class="k">class</span> <span class="nc">AMPDLVisualization</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Philips AMP Visualization Grad-CAM module</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="AMPDLVisualization.grad_cam"><a class="viewcode-back" href="../../api/philipsampdlvis.html#philipsampdlvis.dl_vis_main.AMPDLVisualization.grad_cam">[docs]</a>    <span class="k">def</span> <span class="nf">grad_cam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">processed_input</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">output_orig</span><span class="p">,</span> <span class="n">conv_layer_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selected_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">three_column_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">heat_threashold</span><span class="o">=</span><span class="mi">125</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates and returns a grad-cam heatmap, save it to file as .txt in output_path, with the option to also save as three column format,</span>
<span class="sd">        i.e., original image (output_orig), heatmap (resized to match output_orig), and bounding box overlaid image. </span>

<span class="sd">        The size of the heatmap returned from this API will be the original from the deep learning model output from the layer of conv_layer_name. </span>
<span class="sd">        The three column output will takes the size of output_orig, and resize the heatmap and the overlaid image to the size of output_orig. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            1) model: a loaded keras model with weights</span>
<span class="sd">            2) processed_input: numpy array input pixel data preprocessed to meet the model input requirement. </span>
<span class="sd">               Besides (row, col, ch), additional dimension may be needed, likely in the first dimension, so the input dimension will be (1, row, col, ch)</span>
<span class="sd">            3) output_path: string of the file folder directory in which output will be saved</span>
<span class="sd">            4) output_orig: when three_column_output is True, this numpy array of pixel data will be used in the three colum format: </span>
<span class="sd">               as first column output, and as the base overlaid with heatmap in third column. The order of input image channels is RGB. </span>
<span class="sd">            5) conv_layer_name: string of the name of the convolution layer (usually the last conv layer), default is None. If None is given, then the function</span>
<span class="sd">               will identify last 2D conv-like layer it finds (based on the shape of the layer output). </span>
<span class="sd">            6) selected_class: index of the class to be visualized (typically the predicted class), if None is given, then the class with max score will be used</span>
<span class="sd">            7) three_column_output: boolean whether or not save three column format output, default is True</span>
<span class="sd">            8) heat_threashold: in three_column_output, the second column image is a resized heatmap, and the third column bounding box is derived from the heatmap, based</span>
<span class="sd">               on the threashold level set by this parameter. At 8 bit grayscale, this value range is (0, 255). Default is 125. </span>


<span class="sd">        Returns:</span>
<span class="sd">            a numpy array of heat map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vis_method</span> <span class="o">=</span> <span class="s2">&quot;Grad-CAM&quot;</span>
        <span class="c1"># find the last conv layer</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conv_layer_name</span><span class="p">:</span>
            <span class="n">conv_layer_name</span><span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_get_last_conv_layer_name</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">last_conv_layer</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="n">conv_layer_name</span><span class="p">)</span>

        <span class="c1"># predict class for input</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">processed_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="c1"># multioutput predictions</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">selected_class</span> <span class="ow">and</span> <span class="n">preds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">selected_class</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">preds</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>    <span class="c1"># for number of classes more than 1 (meaning, non-sigmoid output)</span>
            <span class="n">activation_output</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">output</span><span class="p">[:,</span> <span class="n">selected_class</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">activation_output</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">output</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">preds</span><span class="p">[:],</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">preds</span><span class="p">[:],</span> <span class="mf">0.5</span><span class="p">)</span> 

        <span class="c1"># find gradients of predicted class with respect to last conv layer</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gradients</span><span class="p">(</span><span class="n">activation_output</span><span class="p">,</span> <span class="n">last_conv_layer</span><span class="o">.</span><span class="n">output</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">pooled_grads</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># global average pooling gradients per activation map</span>
        
        <span class="n">generate</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="n">model</span><span class="o">.</span><span class="n">input</span><span class="p">,</span>  <span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="p">[</span><span class="n">pooled_grads</span><span class="p">,</span> <span class="n">last_conv_layer</span><span class="o">.</span><span class="n">output</span><span class="p">])</span>

        <span class="n">pooled_grads</span><span class="p">,</span> <span class="n">conv_outputs</span> <span class="o">=</span> <span class="n">generate</span><span class="p">([</span><span class="n">processed_input</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># multiply last conv layer output with pooled grad-values and add them depth-wise</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pooled_grads</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">conv_outputs</span><span class="p">[:,:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">pooled_grads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">conv_outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">heatmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># apply relu</span>
        <span class="n">heatmap</span> <span class="o">/=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
        <span class="n">heatmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">heatmap</span><span class="p">)</span> <span class="c1"># convert to 8-bit</span>

        <span class="k">if</span> <span class="n">three_column_output</span><span class="p">:</span>
            <span class="n">heatmap1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)</span> <span class="c1"># heatmap is (1, col, row)</span>
            <span class="k">assert</span> <span class="n">output_orig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">image_output</span> <span class="o">=</span> <span class="n">output_orig</span><span class="p">[:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#output_orig should be (row, col, ch), and deal with RGB-&gt;BGR in opencv</span>
            <span class="c1"># print(output_orig.shape)</span>
            <span class="n">heatmap1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_resize_images</span><span class="p">(</span><span class="n">heatmap1</span><span class="p">,</span> <span class="n">image_output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># match (row, col) of image_output shape</span>
            <span class="n">heatmap2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">heatmap1</span><span class="p">)</span>
            <span class="n">heatmap2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">heatmap2</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">heat_threashold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">heat_threashold</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">image_bbox</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_get_bbox_from_heat</span><span class="p">(</span><span class="n">image_output</span><span class="p">,</span> <span class="n">heatmap2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">threashold</span><span class="o">=</span><span class="n">heat_threashold</span><span class="p">)</span>
            <span class="n">heatmap1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">applyColorMap</span><span class="p">(</span><span class="n">heatmap1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLORMAP_JET</span><span class="p">)</span> <span class="c1"># from 1 channel greyscale to 3 channel color map</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_get_three_col_grid</span><span class="p">(</span><span class="n">image_output</span><span class="p">,</span> <span class="n">heatmap1</span><span class="p">,</span> <span class="n">image_bbox</span><span class="p">)</span>
            <span class="n">grid_file</span> <span class="o">=</span> <span class="s2">&quot;Grad_CAM_Three_Column_class_</span><span class="si">{}</span><span class="s2">_conv_layer_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selected_class</span><span class="p">,</span> <span class="n">conv_layer_name</span><span class="p">)</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">grid_file</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="n">heatmap_file</span> <span class="o">=</span> <span class="s2">&quot;Grad_CAM_Heatmap_class_</span><span class="si">{}</span><span class="s2">_conv_layer_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selected_class</span><span class="p">,</span> <span class="n">conv_layer_name</span><span class="p">)</span>
        <span class="c1"># cv2.imwrite(os.path.join(output_path, str(heatmap_file), &#39;.jpg&#39;), heatmap[0])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">heatmap_file</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)))</span> <span class="c1"># save heatmap to text file</span>
        <span class="k">return</span> <span class="n">heatmap</span></div>

<div class="viewcode-block" id="AMPDLVisualization.deconvolution"><a class="viewcode-back" href="../../api/philipsampdlvis.html#philipsampdlvis.dl_vis_main.AMPDLVisualization.deconvolution">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">processed_img_arr</span><span class="p">,</span><span class="n">org_img</span><span class="p">,</span><span class="n">layer_names</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">vis_store_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">vis_combine</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                This function is the main interface for the entire deconvolution module.</span>
<span class="sd">                It takes model architecture , model weights and a preprocessed</span>
<span class="sd">                test image as a numpy array, layer name as a string , filter type(&quot;all&quot;/&quot;max&quot;/filter no as string)</span>
<span class="sd">                storage path for stroing the results</span>
<span class="sd">                Parameters:</span>
<span class="sd">                    1) model: model architecture and model weights as input</span>
<span class="sd">                    2) processed_img_arr: numpy array: preprocessed array</span>
<span class="sd">                    3) org_img: original image numpy array</span>
<span class="sd">                    4) layer_names: string: layer name for which the visualization is desired </span>
<span class="sd">                    5) filter_type: type of filter all(as string)/max(as string)/filter no(as string)</span>
<span class="sd">                    6) vis_store_path: string path to store the image</span>
<span class="sd">                    7) vis_combine: whether to combine the input image and plot grid of deconvolution</span>

<span class="sd">                Returns:</span>
<span class="sd">                    1) Deconvolution visulization output </span>
<span class="sd">                    2) Filter numbers</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vis_method</span> <span class="o">=</span> <span class="s2">&quot;Deconvolution&quot;</span>

            <span class="n">all_vis_out_put</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_filter_no</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">list_of_layers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_list_of_layers_to_visualize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">layer_names</span><span class="p">)</span>
            <span class="nb">print</span>  <span class="s2">&quot;Beginning &quot;</span> <span class="o">+</span> <span class="n">vis_method</span> <span class="o">+</span><span class="s2">&quot; for layers :  &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_of_layers</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">list_of_layers</span><span class="p">:</span>
                    <span class="n">model_act</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_layer_activation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">processed_img_arr</span><span class="p">)</span>
                    <span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_deconvolution</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">processed_img_arr</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer</span><span class="p">,</span><span class="n">filter_type</span><span class="p">)</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">_plot_visualization</span><span class="p">(</span><span class="n">org_img</span><span class="p">,</span><span class="n">layer</span><span class="p">,</span><span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">vis_store_path</span><span class="p">,</span><span class="n">vis_method</span><span class="p">,</span><span class="n">vis_combine</span><span class="p">)</span>
                    <span class="n">all_vis_out_put</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vis_out_put</span><span class="p">)</span>
                    <span class="n">all_filter_no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_no</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">all_vis_out_put</span><span class="p">,</span> <span class="n">all_filter_no</span></div>

<div class="viewcode-block" id="AMPDLVisualization.activation_map"><a class="viewcode-back" href="../../api/philipsampdlvis.html#philipsampdlvis.dl_vis_main.AMPDLVisualization.activation_map">[docs]</a>    <span class="k">def</span> <span class="nf">activation_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">processed_img_arr</span><span class="p">,</span> <span class="n">original_image</span><span class="p">,</span> <span class="n">layer_names</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">vis_store_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">vis_combine</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                This function is the main interface/ API for  entire activation map module.</span>
<span class="sd">                It takes model architecture , modelthe weights and a preprocessed</span>
<span class="sd">                test image as a numpy array, layer name as a string , filter type(&quot;all&quot;/&quot;max&quot;/filter number as string)</span>
<span class="sd">                storage path for storing the results</span>
<span class="sd">                 Parameters:</span>
<span class="sd">                    1) model: model architecture and model weights as input</span>
<span class="sd">                    2) processed_img_arr: numpy array: preprocessed array</span>
<span class="sd">                    3) original_image: numpy array: original image numpy array to overlay the activation map</span>
<span class="sd">                    4) layer_name: string: layer name for which the visualization is desired </span>
<span class="sd">                    5) filter_type: string: type of filter all/max/filter</span>
<span class="sd">                    6) vis_store_path: string: output path to store the image</span>
<span class="sd">                    7) vis_combine: True/Falsewhether to combine the input image and plot grid of deconvolution</span>
<span class="sd">                </span>
<span class="sd">                Returns:</span>
<span class="sd">                    1) Grid of activation maps </span>
<span class="sd">                    2) Filter numbers</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vis_method</span> <span class="o">=</span> <span class="s2">&quot;Activationmap&quot;</span>
            <span class="n">vis_method_overlay</span> <span class="o">=</span> <span class="s2">&quot;Activationmap_overlay&quot;</span>
            <span class="n">all_vis_out_put</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_filter_no</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">list_of_layers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_list_of_layers_to_visualize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">layer_names</span><span class="p">)</span>
            <span class="nb">print</span>  <span class="s2">&quot;Beginning &quot;</span> <span class="o">+</span> <span class="n">vis_method</span> <span class="o">+</span><span class="s2">&quot; for layers :  &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_of_layers</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">list_of_layers</span><span class="p">:</span>
                <span class="n">model_act</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_layer_activation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">processed_img_arr</span><span class="p">)</span>
                <span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span><span class="p">,</span><span class="n">out_overlay_imgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_model_activation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">processed_img_arr</span><span class="p">,</span><span class="n">original_image</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer</span><span class="p">,</span><span class="n">filter_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vis_store_path</span><span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">_plot_visualization</span><span class="p">(</span><span class="n">original_image</span><span class="p">,</span><span class="n">layer</span><span class="p">,</span><span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">vis_store_path</span><span class="p">,</span><span class="n">vis_method</span><span class="p">,</span><span class="n">vis_combine</span><span class="p">)</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">_plot_visualization</span><span class="p">(</span><span class="n">original_image</span><span class="p">,</span><span class="n">layer</span><span class="p">,</span><span class="n">out_overlay_imgs</span><span class="p">,</span><span class="n">filter_no</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">vis_store_path</span><span class="p">,</span><span class="n">vis_method_overlay</span><span class="p">,</span><span class="n">vis_combine</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">all_vis_out_put</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vis_out_put</span><span class="p">)</span>
                <span class="n">all_filter_no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_no</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">all_vis_out_put</span><span class="p">,</span> <span class="n">all_filter_no</span></div>

    <span class="k">def</span> <span class="nf">_get_layer_activation_visout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">layer_no</span><span class="p">,</span><span class="n">layer_name</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; this method takes the  model activation for each layers</span>
<span class="sd">                                    filterType, layer number and layer </span>
<span class="sd">                                    to finally compute the activation output of the selected layer with choice of filter type.</span>
<span class="sd">                                    So different computation is done based on the filter_type selected    </span>
<span class="sd">                Parameters:</span>
<span class="sd">                    1) model_act: list of numpy array: </span>
<span class="sd">                    2) filter_type: string:&quot;all&quot;/&quot;max&quot;/filter no as string  </span>
<span class="sd">                    3) layer_no: integer: layer no for which the viualization is required</span>
<span class="sd">                    4) layer_name: layer name: layer name for which the visulization is required </span>
<span class="sd">                Returns:</span>
<span class="sd">                    1)out_imgs: list of numpy array: </span>
<span class="sd">                    2)filter_no: list of integers: indexes of filters for which the out_images are generated for visualization</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">out_imgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filter_no</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="c1">#function to get the layer learning </span>
            <span class="n">layer_activation</span>  <span class="o">=</span> <span class="n">model_act</span><span class="p">[</span><span class="n">layer_no</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span><span class="c1"># if filter type is all</span>
                <span class="n">n_featureMap</span> <span class="o">=</span> <span class="n">layer_activation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_activation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_activation_visout_for_selectedfilter</span><span class="p">(</span><span class="n">layer_activation</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span><span class="c1"># if filter type is max</span>
                <span class="n">n_featureMap</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">filter_no</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_maxactivated_filter_index</span><span class="p">(</span><span class="n">layer_activation</span><span class="p">,</span><span class="n">n_featureMap</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filter_no</span><span class="p">)):</span>
                    <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_activation_visout_for_selectedfilter</span><span class="p">(</span><span class="n">layer_activation</span><span class="p">,</span> <span class="n">filter_no</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span> <span class="ow">or</span>  <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="c1"># if filter type is a filter no  as string </span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">))</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
                    <span class="n">n_featureMap</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">f_no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">)</span>
                    <span class="n">filter_no</span> <span class="o">=</span> <span class="n">f_no</span>
                    <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_activation_visout_for_selectedfilter</span><span class="p">(</span><span class="n">layer_activation</span><span class="p">,</span> <span class="n">filter_no</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> 
            <span class="k">return</span> <span class="n">out_imgs</span><span class="p">,</span> <span class="n">filter_no</span>

    <span class="k">def</span> <span class="nf">_get_activation_visout_for_selectedfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer_act</span><span class="p">,</span><span class="n">filter_no</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; generates the visulaization with a activation function for a selected filter </span>
<span class="sd">                Parameters:</span>
<span class="sd">                    1) layer_act: activation function input </span>
<span class="sd">                    2) filter_no: integer: index fo the filter </span>
<span class="sd">                Returns:</span>
<span class="sd">                    1) img :numpy array:  visualization for the filter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">tempImg</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">filter_no</span><span class="p">:</span>
                    <span class="n">img</span>  <span class="o">=</span> <span class="n">layer_act</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> 
                    
    <span class="k">def</span> <span class="nf">_get_model_layer_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;this function takes keras model and a numpy image array</span>
<span class="sd">                 to generate the layer activation of each layer and returns</span>
<span class="sd">                 a list conatining all activations sequentially</span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) model: keras model</span>
<span class="sd">                        2) data: numpy array: it is the input to the model same dimension as model input </span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) layer_act: list conating layer activation of all layers sequentially</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">layer_outputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
                    <span class="n">layer_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="n">layer_act</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">layer_outputs</span><span class="p">:</span>
                    <span class="n">act</span> <span class="o">=</span>  <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="n">model</span><span class="o">.</span><span class="n">input</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="p">[</span><span class="n">out</span><span class="p">])</span>
                    <span class="n">layer_act</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">act</span><span class="p">([</span><span class="n">data</span><span class="p">,</span><span class="mf">1.</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">layer_act</span>

    <span class="k">def</span> <span class="nf">_get_model_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">original_image</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer_name</span><span class="p">,</span><span class="n">filter_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; _get_model_activation: this function generates the model activtion for each layer</span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) model: keras model</span>
<span class="sd">                        2) data: input image for which the visualization has to be generated</span>
<span class="sd">                        3) model_act: list of numpy array: model layer_names activation for all layers</span>
<span class="sd">                        4) layer_name:string:  layer name  to visualize</span>
<span class="sd">                        5) filter_type: string: &quot;all&quot;/&quot;max&quot;/1,2....n, filter no</span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) output: visualizaion output as list of filter visualization</span>
<span class="sd">                        2) filter_no: list of filter indexe(s)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vis_out_put</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lr_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">filter_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                         <span class="n">lr_no</span> <span class="o">=</span> <span class="n">lr</span>
            <span class="n">vis_out_put</span><span class="p">,</span> <span class="n">filter_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_activation_visout</span><span class="p">(</span><span class="n">model_act</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">lr_no</span><span class="p">,</span><span class="n">layer_name</span><span class="p">)</span>
            <span class="c1"># filter_type is passed as an argument to verify the type of filter to do overlay</span>
            <span class="n">out_overlay_imgs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_plot_overlay</span><span class="p">(</span><span class="n">original_image</span><span class="p">,</span><span class="n">model_act</span><span class="p">[</span><span class="n">lr_no</span><span class="p">],</span><span class="n">filter_type</span><span class="p">,</span><span class="n">filter_no</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span><span class="p">,</span><span class="n">out_overlay_imgs</span>
            
    <span class="k">def</span> <span class="nf">_get_model_deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer_name</span><span class="p">,</span><span class="n">filter_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; _get_model_deconvolution: this function generates the layer visualzation</span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) model: keras model</span>
<span class="sd">                        2) data: input image for which the visualization has to be generated</span>
<span class="sd">                        3) model_act: list of numpy array: model layer_names activation for all layers</span>
<span class="sd">                        4) layer_name:string:  layer name  to visualize</span>
<span class="sd">                        5) filter_type: string: &quot;all&quot;/&quot;max&quot;/1,2....n, filter no</span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) output: visualizaion output as list of filter visualization</span>
<span class="sd">                        2) filter_no: list of filter indexe(s)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">deconv_layer</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">vis_out_put</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lr_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">filter_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span><span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                             <span class="n">lr_no</span> <span class="o">=</span> <span class="n">lr</span>
            <span class="n">nonConv</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span>  <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">],</span><span class="n">Conv2D</span><span class="p">):</span>
                 <span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_deconvolution</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer_name</span><span class="p">)</span>
                 <span class="n">vis_out_put</span><span class="p">,</span> <span class="n">filter_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_visualization_output</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">lr_no</span><span class="p">,</span><span class="n">layer_name</span><span class="p">,</span><span class="n">nonConv</span><span class="p">)</span>
            <span class="k">elif</span>  <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">],</span><span class="n">MaxPooling2D</span><span class="p">):</span>
                 <span class="n">nonConv</span> <span class="o">=</span> <span class="kc">True</span>
                 <span class="n">deconv_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_maxpoolinglayer_info</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">layer_name</span><span class="p">)</span>
                 <span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_deconvolution</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">deconv_layer</span><span class="p">)</span>
                 <span class="n">vis_out_put</span><span class="p">,</span> <span class="n">filter_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_layer_visualization_output</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">lr_no</span><span class="p">,</span><span class="n">layer_name</span><span class="p">,</span><span class="n">nonConv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                 <span class="nb">print</span> <span class="n">layer_name</span> <span class="o">+</span> <span class="s2">&quot; is not supported for deconvolution.&quot;</span>
            <span class="k">return</span> <span class="n">vis_out_put</span><span class="p">,</span><span class="n">filter_no</span>

    <span class="k">def</span> <span class="nf">_get_layer_deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer_name</span><span class="p">):</span>
     
            <span class="n">layer_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#get the layer no from layer name</span>
            <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span><span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                         	<span class="n">layer_no</span> <span class="o">=</span> <span class="n">lr</span>
            <span class="n">deconv_model_input</span><span class="o">=</span> <span class="n">model_act</span><span class="p">[</span><span class="n">layer_no</span><span class="p">]</span>
            <span class="n">deconv_model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
            <span class="c1"># go from  layer of interest to the input before layer in reverse order</span>
            <span class="c1"># get all Parameters: to input model layer and make a transpose of the same </span>
            <span class="c1"># create a new deconv model and add the transpose layer to it </span>
            <span class="k">for</span> <span class="n">lr_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># leave the input layer </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">lr_no</span> <span class="o">&lt;=</span> <span class="n">layer_no</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lr_no</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
                         <span class="c1"># if the desired layer is a Conv2D layer </span>
                         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">],</span><span class="n">Conv2D</span><span class="p">):</span>
                                <span class="c1">#it is a convolution layer in the model</span>
                                <span class="c1">#add a deconv layer in the model</span>
                                <span class="n">out_shape</span> <span class="o">=</span>  <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
                                <span class="n">layer_act</span>  <span class="o">=</span> <span class="n">model_act</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span>
                                <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                                <span class="n">layer_padding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                                <span class="n">layer_strides</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                                <span class="n">k_size</span> <span class="o">=</span>  <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">kernel_size</span>
                                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                                     <span class="n">layer_strides</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
                                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">padding</span><span class="p">:</span>
                                     <span class="n">layer_padding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">padding</span>
                                <span class="k">if</span> <span class="n">layer_padding</span> <span class="ow">and</span> <span class="n">layer_strides</span><span class="p">:</span>
                                     <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span> <span class="n">k_size</span><span class="p">,</span>
                                                                         <span class="n">padding</span><span class="o">=</span> <span class="n">layer_padding</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">strides</span><span class="o">=</span> <span class="n">layer_strides</span><span class="p">,</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">,</span>
                                                                                         <span class="n">name</span> <span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">elif</span> <span class="ow">not</span> <span class="n">layer_padding</span> <span class="ow">and</span> <span class="n">layer_strides</span><span class="p">:</span>
                                     <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span> <span class="n">k_size</span><span class="p">,</span>
                                                                         <span class="n">padding</span><span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">strides</span><span class="o">=</span> <span class="n">layer_strides</span><span class="p">,</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">,</span>
                                                                         <span class="n">name</span> <span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">layer_padding</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">layer_strides</span><span class="p">:</span>
                                     <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span> <span class="n">k_size</span><span class="p">,</span>
                                                                         <span class="n">padding</span><span class="o">=</span> <span class="n">layer_padding</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">,</span>
                                                                         <span class="n">name</span> <span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">elif</span> <span class="ow">not</span> <span class="n">layer_padding</span>  <span class="ow">and</span> <span class="ow">not</span> <span class="n">layer_strides</span><span class="p">:</span>
                                     <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="n">out_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span> <span class="n">k_size</span><span class="p">,</span>
                                                                            <span class="n">padding</span><span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                            <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">,</span>
                                                                                        <span class="n">name</span> <span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
                         <span class="c1"># if the desire layer is max pooling layer </span>
                         <span class="k">elif</span>  <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">],</span><span class="n">MaxPooling2D</span><span class="p">):</span>
                                <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">UpSampling2D</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">data_format</span><span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">image_data_format</span><span class="p">(),</span>
                                                         <span class="n">name</span> <span class="o">=</span><span class="s1">&#39;unpool_&#39;</span><span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">lr_no</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                         <span class="k">else</span><span class="p">:</span>
                                <span class="k">pass</span>
            <span class="c1"># analyze the first layer of the input model </span>
            <span class="c1"># if it is a instace of Input layer then do nothing</span>
            <span class="c1"># if it is a instance of Conv2D layer then asdd a transpose of the same  </span>
            <span class="k">if</span>  <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">InputLayer</span><span class="p">):</span>
                         <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Conv2D</span><span class="p">):</span>
                         <span class="n">layer_act</span> <span class="o">=</span> <span class="n">model_act</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                         <span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">layer_act</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                         <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
    
                         <span class="n">f_no</span><span class="o">=</span>  <span class="n">out_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                         <span class="n">layer_padding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                         <span class="n">layer_strides</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                         <span class="n">k_size</span> <span class="o">=</span>  <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kernel_size</span>
                         <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                                     <span class="n">layer_strides</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span>
                         <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">padding</span><span class="p">:</span>
                                     <span class="n">layer_padding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">padding</span>
                         <span class="n">deconv_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2DTranspose</span><span class="p">(</span><span class="n">f_no</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span> <span class="n">k_size</span><span class="p">,</span>  <span class="n">padding</span><span class="o">=</span><span class="n">layer_padding</span><span class="p">,</span>
                                                                                 <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>  <span class="n">strides</span><span class="o">=</span> <span class="n">layer_strides</span><span class="p">,</span>
                                                                                 <span class="n">input_shape</span> <span class="o">=</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    
            <span class="k">else</span><span class="p">:</span>
                         <span class="k">pass</span>
            <span class="n">deconv_model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">,</span><span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
            <span class="k">return</span>  <span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span>

    <span class="k">def</span> <span class="nf">_get_maxpoolinglayer_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">layer_name</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; this function finds the layer_names near to desired max pooling layer to start the deconvolution.</span>
<span class="sd">                                     as to create a deconvolution model from the convolution model. </span>
<span class="sd">                                     The first layer of the deconvolion model needs to be a convolution layer, thus the deconvolution </span>
<span class="sd">                                     needs to be intiated from a conv2d layers near to max pool layer  </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1)model: keras model</span>
<span class="sd">                        2)layer_name: string: desired layer name for deconvolution </span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) layer name: returns the nearest layer name</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">all_layers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_markedInd</span> <span class="o">=</span>  <span class="p">[]</span>
            <span class="n">layer_indx</span> <span class="o">=</span> <span class="mi">0</span>
    
            <span class="k">for</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                         <span class="n">layer_indx</span> <span class="o">=</span> <span class="n">indx</span>
                    <span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span><span class="n">Conv2D</span><span class="p">)</span><span class="o">&amp;</span> <span class="p">(</span><span class="n">indx</span><span class="o">&gt;</span><span class="n">layer_indx</span><span class="p">):</span>
                            <span class="n">all_markedInd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span><span class="n">Flatten</span><span class="p">)</span><span class="o">&amp;</span> <span class="p">(</span><span class="n">indx</span><span class="o">&gt;</span><span class="n">layer_indx</span><span class="p">):</span>
                            <span class="n">all_markedInd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
            <span class="n">deconv_indx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">all_markedInd</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">layer_indx</span><span class="p">))</span>
            <span class="k">return</span>  <span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">deconv_indx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_get_layer_visualization_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_type</span><span class="p">,</span><span class="n">layerNo</span><span class="p">,</span><span class="n">layer_name</span><span class="p">,</span><span class="n">nonConv</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; this method takes the deconvolted model, deconvoluted model input, model activation for each layers</span>
<span class="sd">                                    layerNo, filterTypw and layer nake and wether it is for aconvolutional layer or not flg </span>
<span class="sd">                                    to finally compute the deconvolution output of the selected layer with choice of filter type.</span>
<span class="sd">                                    So different computation is done based on the filter_type selected    </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) deconv_model: keras model: </span>
<span class="sd">                        2) model_act: list of numpy array: </span>
<span class="sd">                        3) deconv_model_input: numpy array:</span>
<span class="sd">                        4) filter_type: string:&quot;all&quot;/&quot;max&quot;/filter no as string  </span>
<span class="sd">                        5) layerNo: integer: layer no for which the viualization is required</span>
<span class="sd">                        6) layer_name: layer name: layer name for which the visulization is required </span>
<span class="sd">                        7) nonConv: boolean: flag to separate operation for a conv2D layer and a non conv@d layer</span>
<span class="sd">                     Returns</span>
<span class="sd">                     -------</span>
<span class="sd">                        1)out_imgs: list of numpy array: </span>
<span class="sd">                        2)filter_no: list of integers: indexes of filters for which the out_images are generated for visualization</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">out_imgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filter_no</span> <span class="o">=</span> <span class="mi">10000</span>
            <span class="k">if</span> <span class="n">nonConv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span><span class="c1"># if the layer is not a conv2D layer e.g max pooling layer</span>
                 <span class="c1">#function to get the layer learning </span>
                 <span class="n">outfun</span><span class="p">,</span><span class="n">layerAct</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_deconv_layer_activation_function</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layerNo</span><span class="p">,</span><span class="n">layer_name</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span><span class="c1"># if filter type is all</span>
                        <span class="n">n_featureMap</span> <span class="o">=</span> <span class="n">layerAct</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layerAct</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                                <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_act_fun_visout_for_selectedfilter</span><span class="p">(</span><span class="n">outfun</span><span class="p">,</span><span class="n">layerAct</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
                 <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span><span class="c1"># if filter type is max</span>
                        <span class="n">n_featureMap</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">filter_no</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_maxactivated_filter_index</span><span class="p">(</span><span class="n">layerAct</span><span class="p">,</span><span class="n">n_featureMap</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filter_no</span><span class="p">)):</span>
                                <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_act_fun_visout_for_selectedfilter</span><span class="p">(</span><span class="n">outfun</span><span class="p">,</span><span class="n">layerAct</span><span class="p">,</span> <span class="n">filter_no</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
                 <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span> <span class="ow">or</span>  <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="c1"># if filter type is a filter no  as string </span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">))</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
                             <span class="n">n_featureMap</span> <span class="o">=</span> <span class="mi">1</span>
                             <span class="n">f_no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">)</span>
                             <span class="n">filter_no</span> <span class="o">=</span> <span class="n">f_no</span>
                             <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_act_fun_visout_for_selectedfilter</span><span class="p">(</span><span class="n">outfun</span><span class="p">,</span><span class="n">layerAct</span><span class="p">,</span> <span class="n">filter_no</span><span class="p">))</span>
                 <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span> 
    
            <span class="k">else</span><span class="p">:</span><span class="c1"># if the layer is a conv2d layer</span>
                 <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span><span class="c1"># if filter type is all</span>
                        <span class="n">n_featureMap</span> <span class="o">=</span> <span class="n">deconv_model_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deconv_model_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                                <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_deconv_visout_for_selectedfilter</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">idx</span><span class="p">))</span>
                 <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span><span class="c1"># if filter type is max</span>
                        <span class="n">n_featureMap</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">filter_no</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_maxactivated_filter_index</span><span class="p">(</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">n_featureMap</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filter_no</span><span class="p">)):</span>
                                 <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_deconv_visout_for_selectedfilter</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_no</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
                        
                 <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span> <span class="ow">or</span>  <span class="n">filter_type</span> <span class="o">!=</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span><span class="c1"># if filter type is a filter no  as string</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">))</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
                             <span class="n">f_no</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filter_type</span><span class="p">)</span>
                             <span class="n">filter_no</span> <span class="o">=</span> <span class="n">f_no</span>
                             <span class="n">out_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_deconv_visout_for_selectedfilter</span><span class="p">(</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_no</span><span class="p">))</span>
                 <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">return</span> <span class="n">out_imgs</span><span class="p">,</span> <span class="n">filter_no</span>

    <span class="k">def</span> <span class="nf">_get_deconv_layer_activation_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">model_act</span><span class="p">,</span><span class="n">layer_no</span><span class="p">,</span><span class="n">layer_name</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; _get_deconv_layer_activation_function:</span>
<span class="sd">                    this method creates a activation function with a input and output layer </span>
<span class="sd">                    for selecte layer for deconvolution.  </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) deconv_model: deconvolted keras model </span>
<span class="sd">                        2) model_act:list of numpy array: </span>
<span class="sd">                        3)layerNo: integer:  layer no </span>
<span class="sd">                        4)layer_name: string: layer name</span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) output_fn: normalized numpy array</span>
<span class="sd">                        2)layerAct </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">keras</span> <span class="k">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
            <span class="n">layer_act</span>  <span class="o">=</span> <span class="n">model_act</span><span class="p">[</span><span class="n">layer_no</span><span class="p">]</span>
            <span class="n">in_layer_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out_layer_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ilr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deconv_model</span><span class="o">.</span><span class="n">layers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">deconv_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">ilr</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                         <span class="n">in_layer_idx</span> <span class="o">=</span> <span class="n">ilr</span>
            <span class="n">out_layer_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">deconv_model</span><span class="o">.</span><span class="n">layers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">output_layer</span> <span class="o">=</span> <span class="n">deconv_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">out_layer_idx</span><span class="p">]</span><span class="o">.</span><span class="n">output</span>
            <span class="n">input_layer</span> <span class="o">=</span>  <span class="n">deconv_model</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">in_layer_idx</span><span class="p">]</span><span class="o">.</span><span class="n">input</span>
            <span class="n">vis_out_put_fn</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">([</span><span class="n">input_layer</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()],</span> <span class="p">[</span><span class="n">output_layer</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">vis_out_put_fn</span><span class="p">,</span> <span class="n">layer_act</span>

    <span class="k">def</span> <span class="nf">_get_deconv_visout_for_selectedfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">deconv_model</span><span class="p">,</span><span class="n">deconv_model_input</span><span class="p">,</span><span class="n">filter_no</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; this method generates the deconvolution visualization for a selected filter </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1)deconv_model : deconvolted keras model  </span>
<span class="sd">                        2)deconv_model_input: numpy array: activaion from the input model for the </span>
<span class="sd">                                                                     selcted layer </span>
<span class="sd">                        3) filter_no: integer: index fo the filter</span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) img :numpy array:  visualization for the filter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">layer_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">deconv_model_input</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">layer_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">filter_no</span><span class="p">:</span>
                         <span class="n">layer_input</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">deconv_model_input</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">vis_out_put</span> <span class="o">=</span> <span class="n">deconv_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">layer_input</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">vis_out_put</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">img</span>

    <span class="k">def</span> <span class="nf">_get_act_fun_visout_for_selectedfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">func_input</span><span class="p">,</span><span class="n">filter_no</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; generates the visulaization with a activation function for a selected filter </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) func: activation function</span>
<span class="sd">                        2) funcInput: activation function input </span>
<span class="sd">                        3) filter_no: integer: index fo the filter </span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) img :numpy array:  visualization for the filter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">temp_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">func_input</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">func_input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">filter_no</span><span class="p">:</span>
                         <span class="n">temp_input</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">func_input</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vis_out_put</span> <span class="o">=</span><span class="n">func</span><span class="p">([</span><span class="n">temp_input</span><span class="p">,</span><span class="mf">1.</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis_out_put</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">img</span>

    <span class="k">def</span> <span class="nf">_get_maxactivated_filter_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">n_featureMap</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; _get_maxactivated_filter_index:</span>
<span class="sd">                    this function takes all the filter activation and finds out the top </span>
<span class="sd">                    activated filter and returns its index </span>
<span class="sd">                    Parameters:</span>
<span class="sd">                        1) arr:numpy array:numpy array with all filter activation </span>
<span class="sd">                        2) n_featureMap:no of filters with top max activation </span>
<span class="sd">                    Returns:</span>
<span class="sd">                        1) max_idx: integer: index of max activated filter </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">list_max</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">list_max2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="n">X_activ</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">X_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_activ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">list_max2</span> <span class="o">+=</span> <span class="n">X_sum</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">list_max</span> <span class="o">+=</span> <span class="n">X_sum</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">list_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_max</span><span class="p">)</span>
            <span class="n">list_max2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="n">list_max2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">list_max2</span><span class="p">)</span><span class="o">-</span><span class="n">n_featureMap</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">list_max2</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">max_val</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_max</span><span class="p">))</span>  <span class="k">if</span> <span class="n">list_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                    <span class="n">max_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">max_idx</span></div>
        


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, sunil vuppala.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>